// Holds unrelated common functions between the scripts (do not use module attributes)
// Required envs must be called with `env!` here to make sure they are defined in tests and else

/// Holds the absolute path to the original source folder for makers scripts (including this one).
#[allow(dead_code)]
const SCRIPTS: &str = env!("SCRIPTS");

/// Holds the path to Cargo TOML.
#[allow(dead_code)]
const CARGO_TOML_PATH: &str = concat!(env!("SCRIPTS"), "/../Cargo.toml");

/// See the Cargo Make file.
#[allow(dead_code)]
const INSTALL_FULL_LIBDIR: &str = env!("INSTALL_FULL_LIBDIR");

/// See the Cargo Make file.
#[allow(dead_code)]
const INSTALL_FULL_INCLUDEDIR: &str = env!("INSTALL_FULL_INCLUDEDIR");

/// See the Cargo Make file.
#[allow(dead_code)]
const INSTALL_FULL_BINDIR: &str = env!("INSTALL_FULL_BINDIR");

/// The default library extension for this platform.
#[allow(dead_code)]
const LIBEXT: &str = env!("LIBEXT");

/// Holds `release` or `debug`
#[allow(dead_code)]
const TARGET_PROFILE: &str = env!("TARGET_PROFILE");

/// Holds the target directory.
#[allow(dead_code)]
const TARGET: &str = env!("CARGO_MAKE_CRATE_TARGET_DIRECTORY");

/// Holds the name of the crate.
#[allow(dead_code)]
const CRATE_NAME: &str = env!("CARGO_MAKE_CRATE_NAME");

/// Holds the export of the final C header (generated by cbindgen).
#[allow(dead_code)]
const C_HEADER: &str = env!("C_HEADER");

/// Get a `[label]` to the next one as lines.
#[allow(dead_code)]
fn toml_section<'src, 'k>(
    toml_content: &'src str,
    section: &'k str,
) -> impl Iterator<Item = &'src str> {
    // find the respective section
    toml_content
        .split_once(&format!("[{}]", section))
        .unwrap_or_default()
        .1
        .split("\n") // convert to lines
        .filter_map(|line| {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                None
            } else {
                Some(line)
            }
        }) // if commented or empty, discard
        .take_while(|line| !(line.starts_with('[') && line.ends_with(']'))) // until next section
}

/// Prints a command into a vector as it would run in shell.
#[allow(dead_code)]
fn command_get_string(cmd: &std::process::Command) -> Vec<&str> {
    let mut v = vec![cmd.get_program().to_str().unwrap()];
    v.extend(cmd.get_args().map(|i| i.to_str().unwrap()));
    v
}

/// Returns the full text of `Cargo.toml`.
#[allow(dead_code)]
fn cargo_toml() -> String {
    std::fs::read_to_string(CARGO_TOML_PATH).expect(
        "either Cargo.toml is not there or CARGO_TOML_PATH and SCRIPTS are set to invalid paths",
    )
}

/// Create `cargo VERB --no-default-features` with all the possible feature combinations.
#[allow(dead_code)]
fn cargo_verb_all_feature_combinations<'a>(
    verb: &'a str,
) -> impl Iterator<Item = (String, std::process::Command)> + 'a {
    let cargo_toml = cargo_toml();
    let features = toml_section(&cargo_toml, "features")
        .filter_map(|line| line.split_once('=').map(|(i, _)| i.trim()))
        .collect::<Vec<_>>();

    let combinations = combinations(&features)
        .into_iter()
        .map(|row| row.into_iter().map(|i| *i).collect::<Vec<_>>().join(","))
        .collect::<Vec<String>>();

    combinations.into_iter().map(move |feature_arg| {
        let mut cmd = std::process::Command::new("cargo");
        cmd.args([verb, "--no-default-features", "--features", &feature_arg]);
        (feature_arg, cmd)
    })
}

/// Run and log [`cargo_verb_all_feature_combination`] with a given verb.
#[allow(dead_code)]
fn cargo_verb_all_feature_combinations_run(verb: &str) -> Result<(), ()> {
    let cmds = cargo_verb_all_feature_combinations(verb);

    let total_count = cmds.size_hint().1;
    let total_count_space = total_count.map(|i| format!(" {}", i)).unwrap_or_default();
    let total_count_slash = total_count.map(|i| format!("/{}", i)).unwrap_or_default();
    println!(
        "Running `{}` for{} combinations of flags",
        verb, total_count_space,
    );

    let mut had_error = false;
    for (i, (features, mut cmd)) in cmds.enumerate() {
        print!(
            "({}{}) Running `{}` for features: `{}`... ",
            i + 1,
            total_count_slash,
            verb,
            features,
        );
        let _ = std::io::Write::flush(&mut std::io::stdout()); // makes for nicer output

        match cmd.output() {
            Ok(_) => {
                println!("Ok.")
            }
            Err(_) => {
                println!("Failed.");
                had_error = true;
            }
        }
    }

    if had_error {
        Err(())
    } else {
        Ok(())
    }
}

/// Give all the possible combinations (non-duplicate) of values in this.
#[allow(dead_code)]
fn combinations<T>(v: &[T]) -> Vec<Vec<&T>> {
    let combination_indices = combination_indices(v.len());

    combination_indices
        .into_iter()
        .map(|row| row.into_iter().map(|col| &v[col]).collect())
        .collect()
}

/// Create vectors of every combination of `len` items.
#[allow(dead_code)]
fn combination_indices(len: usize) -> Vec<Vec<usize>> {
    // handle the simplest case to ensure unwraps work on empy stuff for simple algo later
    if len == 0 {
        return Default::default();
    }

    let max = len - 1;
    let mut rows = vec![vec![0]];

    while rows.last().unwrap().len() != len {
        let mut new_row = rows.last().unwrap().clone();
        let bumpable = new_row
            .iter()
            .rev()
            .enumerate()
            .find(|(rev_index, item)| **item < (max - rev_index))
            .map(|(rev_index, _)| new_row.len() - 1 - rev_index);

        if let Some(bumpable) = bumpable {
            new_row[bumpable] += 1;
            // reset everything after that
            for (offset, i) in ((bumpable + 1)..new_row.len()).enumerate() {
                new_row[i] = new_row[bumpable] + offset + 1;
            }
        } else {
            new_row = (0..(new_row.len() + 1)).into_iter().collect();
        }
        rows.push(new_row);
    }

    rows
}
