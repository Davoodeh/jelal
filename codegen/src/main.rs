//! Create exact copies of the given sources for FFI.
//!
//! The main code lives at "visit" module. There are many limitations and caveats to take into
//! account before using. Read the docs for that module carefully.
//!
//! There are limitations to what this crate is designed to do.
//! - The list of structs to parse and whitelist is hardcoded with [`IDENTS`].
//!
//! Alongside the list of limitations, this crate is opinionated and using [`RustFfi`] comes with
//! caveats and other sets of limitations defined in its doc.

use std::{error::Error, fs::read_to_string, io::Write};

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{visit_mut::VisitMut, File, Item};

use crate::visit_mut::RustFfi;

mod resolve_type;
mod sift;
mod util;
mod visit_mut;

// features
const STD_FEATURE: &str = "std";
const PY_FEATURE: &str = "py";
const C_FEATURE: &str = "c";
const WASM_FEATURE: &str = "wasm";

/// Match the idents defined here.
const IDENTS: &[&str] = &["Date", "Month", "MonthDay", "Ordinal", "Year"];

/// Inside these files.
const FILES: [&str; 2] = ["lib.rs", "primitive.rs"];
const OUTPUT: &str = "ffi/generated.rs";

const FILES_PREFIX: &str = "../src/";

const LIB_NAME: &str = "jelal";

fn prefixed_path(path: &str) -> String {
    format!("{}{}", FILES_PREFIX, path)
}

fn parse_file(path: &str) -> Result<Vec<Item>, Box<dyn Error>> {
    let content = read_to_string(prefixed_path(path))?;
    let parsed = syn::parse_file(&content)?;
    Ok(parsed.items)
}

fn write_output(content: impl ToString) -> Result<(), Box<dyn Error>> {
    // path="src/$path"
    let path_binding = prefixed_path(OUTPUT);
    let path = std::path::Path::new(&path_binding);

    // mkdir -p $(basedir $path)
    if let Some(parent) = path.parent() {
        let _ = std::fs::create_dir_all(parent);
    }

    // echo $src > $path
    std::fs::File::create(path).and_then(|mut i| i.write_all(content.to_string().as_bytes()))?;

    // rustfmt if possible
    const ERR_INTRO: &str = " `rustfmt` was called and failed";
    match std::process::Command::new("rustfmt")
        .arg(path)
        .spawn()
        .and_then(|mut i| i.wait())
    {
        Ok(exit_status) if exit_status.success() => {}
        Ok(exit_status) => {
            println!("{} with a failure exit status: {}", ERR_INTRO, exit_status)
        }
        Err(e) => println!("{}: {}", ERR_INTRO, e),
    }

    Ok(())
}

fn generate_content(items: Vec<Item>) -> TokenStream {
    let mut file = File {
        shebang: Default::default(),
        attrs: Default::default(),
        items,
    };
    RustFfi::new(IDENTS.iter().map(|i| format_ident!("{}", i)).collect()).visit_file_mut(&mut file);
    let items = file.items;

    quote! {
        #![doc(hidden)]
        //! Automatically @generated by the internal codegen tool.
        //!
        //! Modify the source that source for control on what to include and how.

        #![cfg_attr(feature = #PY_FEATURE, allow(unsafe_op_in_unsafe_fn))]

        #[cfg(feature = #PY_FEATURE)]
        use pyo3::prelude::*;

        #[allow(unused_imports)]
        #[cfg(feature = #STD_FEATURE)]
        use std::prelude::*;

        #[cfg(feature = #WASM_FEATURE)]
        use wasm_bindgen::prelude::*;

        #(#items)*
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("run from the root of this binary's project");

    let files = FILES
        .into_iter()
        .map(parse_file)
        .collect::<Result<Vec<Vec<Item>>, _>>()?;
    println!("read: {:?}", FILES);

    let content = generate_content(files.into_iter().flatten().collect());

    write_output(content)?;
    println!("wrote: {:?}", OUTPUT);

    Ok(())
}
