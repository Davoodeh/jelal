//! Create exact copies of the given sources for FFI.
//!
//! The main code lives at "visit" module. There are many limitations and caveats to take into
//! account before using. Read the docs for that module carefully.
//!
//! There are limitations to what this crate is designed to do.
//! - The list of structs to parse and whitelist is hardcoded with [`IDENTS`].
//!
//! Alongside the list of limitations, this crate is opinionated and using [`RustFfi`] comes with
//! caveats and other sets of limitations defined in its doc.

use std::{error::Error, fs::read_to_string, io::Write};

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{visit_mut::VisitMut, File, Item};

use crate::visit_mut::RustFfi;

pub use codegen::*;

fn parse_file(path: &str) -> Result<Vec<Item>, Box<dyn Error>> {
    let content = read_to_string(prefixed_path(path))?;
    let parsed = syn::parse_file(&content)?;
    Ok(parsed.items)
}

/// Write the content to the path and create the directory if not there.
fn write_output<S: AsRef<std::ffi::OsStr> + ?Sized>(
    path: &S,
    content: impl ToString,
) -> Result<(), std::io::Error> {
    let path = std::path::Path::new(&path);

    // mkdir -p $(basedir $path)
    if let Some(parent) = path.parent() {
        let _ = std::fs::create_dir_all(parent);
    }

    // echo $src > $path
    std::fs::File::create(path).and_then(|mut i| i.write_all(content.to_string().as_bytes()))
}

fn generate_content(items: Vec<Item>) -> TokenStream {
    let mut file = File {
        shebang: Default::default(),
        attrs: Default::default(),
        items,
    };
    RustFfi::new(IDENTS.iter().map(|i| format_ident!("{}", i)).collect()).visit_file_mut(&mut file);
    let items = file.items;

    quote! {
        #![doc(hidden)]
        //! Automatically @generated by the internal codegen tool.
        //!
        //! Modify the source that source for control on what to include and how.

        #![allow(deprecated)]

        #![cfg_attr(feature = #PY_FEATURE, allow(unsafe_op_in_unsafe_fn))]

        #[cfg(feature = #PY_FEATURE)]
        use pyo3::prelude::*;

        #[allow(unused_imports)]
        #[cfg(feature = #STD_FEATURE)]
        use std::prelude::*;

        #[cfg(feature = #WASM_FEATURE)]
        use wasm_bindgen::prelude::*;

        #(#items)*
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("run from the root of this binary's project");

    let files = FILES
        .into_iter()
        .map(parse_file)
        .collect::<Result<Vec<Vec<Item>>, _>>()?;
    println!("read: {:?}", FILES);

    let content = generate_content(files.into_iter().flatten().collect());

    let path = prefixed_path(OUTPUT);
    write_output(&path, content)?;
    println!("wrote: {:?}", OUTPUT);

    // rustfmt if possible
    const ERR_INTRO: &str = " `rustfmt` was called and failed";
    match std::process::Command::new("rustfmt")
        .arg(path)
        .spawn()
        .and_then(|mut i| i.wait())
    {
        Ok(exit_status) if exit_status.success() => {
            println!("formatted using `rustfmt`")
        }
        Ok(exit_status) => {
            println!("{} with a failure exit status: {}", ERR_INTRO, exit_status)
        }
        Err(e) => println!("{}: {}", ERR_INTRO, e),
    }

    Ok(())
}
