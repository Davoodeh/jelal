#![doc(hidden)]
#![doc = r" Automatically @generated by the internal codegen tool."]
#![doc = r""]
#![doc = r" Modify the source that source for control on what to include and how."]
#![allow(deprecated)]
#![cfg_attr(feature = "py", allow(unsafe_op_in_unsafe_fn))]
#[cfg(feature = "py")]
use pyo3::prelude::*;
#[allow(unused_imports)]
#[cfg(feature = "std")]
use std::prelude::*;
#[cfg(feature = "wasm")]
use wasm_bindgen::prelude::*;
#[doc = " The day of the month and its related month in a leap year."]
#[cfg_attr(feature = "c", repr(C))]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pyclass)]
#[derive(Clone)]
pub struct MonthDay {
    #[doc = " The month of the year."]
    month: Month,
    #[doc = " The day of the associated month."]
    day: UMonthDay,
}
#[cfg_attr(feature = "py", pymethods)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl MonthDay {
    #[doc = " Return the ordinal (day of the year) for this month and its day."]
    pub fn to_ordinal(&self) -> Ordinal {
        let this = self;
        let this: &crate::MonthDay = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::MonthDay::to_ordinal(this)) }
    }
    #[doc = " Return the value of inner `Self::month` for this instance."]
    pub fn month(&self) -> Month {
        let this = self;
        let this: &crate::MonthDay = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::MonthDay::month(this)) }
    }
    #[doc = " Return the value of inner `Self::day` for this instance."]
    pub fn day(&self) -> UMonthDay {
        let this = self;
        let this: &crate::MonthDay = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::MonthDay::day(this)) }
    }
}
#[doc = " A Jalali valid date.\n\n See [`Year`] for more information about year count. [`Self::MIN`] to [`Self::MAX`] is the\n representable range (not necessarily all correct in leap calculation or conversion). Year 0 is\n not a valid year (see [`Year::ZERO_REPLACEMENT`])."]
#[cfg_attr(feature = "c", repr(C))]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pyclass)]
#[derive(Clone)]
pub struct Date {
    #[doc = " The year of this date."]
    year: Year,
    #[doc = " The number of days passed since the start of the year."]
    ordinal: Ordinal,
}
#[cfg_attr(feature = "py", pymethods)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Date {
    #[doc = " Return how many days on this date will result to the given destination.\n\n This is exactly as [`Self::diff_as_days_strict`] but returns the value only."]
    pub fn diff_as_days(&self, other: Date) -> IDayDiff {
        let this = self;
        let this: &crate::Date = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Date::diff_as_days(this, other.into())) }
    }
    #[doc = " Return how many days has passed since or is yet to reach [`Self::EPOCH`].\n\n This is exactly as [`Self::diff_epoch_strict`] but returns the value only."]
    pub fn diff_epoch(&self) -> IDayDiff {
        let this = self;
        let this: &crate::Date = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Date::diff_epoch(this)) }
    }
    #[doc = " Return the value of inner `Self::year` for this instance."]
    pub fn year(&self) -> Year {
        let this = self;
        let this: &crate::Date = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Date::year(this)) }
    }
    #[doc = " Return the value of inner `Self::ordinal` for this instance."]
    pub fn ordinal(&self) -> Ordinal {
        let this = self;
        let this: &crate::Date = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Date::ordinal(this)) }
    }
}
#[doc = " Counts consecutive days for addition and subtraction operations."]
pub type IDayDiff = i32;
#[doc = " Unsigned variant of [`IDayDiff`]. This is to be avoided if the signed variant can be used."]
pub type UDayDiff = u32;
#[doc = " The unsigned primitive type for counting days of a [`Month`]."]
pub type UMonthDay = u8;
#[doc = " The signed equal day counter type for [`UMonthDay`]."]
pub type IMonthDay = i8;
#[doc = " An alias for a commonly used format of Jalali as a type (Year, Month, Day)."]
pub type Ymd = (Year, Month, UMonthDay);
#[doc = " The primitive underlying types for [`Ymd`]."]
pub type IntYmd = (IYear, UMonth, UMonthDay);
#[doc = " The default primitive that holds all the values for months ([`Month::MIN`] to [`Month::MAX`])."]
pub type UMonth = u8;
#[doc = " Signed variant of the default primitive [`UMonth`]."]
pub type IMonth = i8;
#[doc = " The default primitive that holds all the ordinals ([`Ordinal::MIN`] to [`Ordinal::MAX`])."]
pub type UOrdinal = u16;
#[doc = " Signed variant of the default primitive [`UOrdinal`]."]
pub type IOrdinal = i16;
#[doc = " The default primitive that holds all the years ([`Year::MIN`] to [`Year::MAX`]).\n\n There is no unsigned equivalent for this type like the others."]
pub type IYear = i32;
#[doc = " Holds valid months count."]
#[cfg_attr(feature = "c", repr(transparent))]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pyclass)]
#[derive(Clone)]
pub struct Month(UMonth);
#[cfg_attr(feature = "py", pymethods)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Month {
    #[doc = " Convert a valid month to ordinal assuming 0th day of the month (-1) if month is valid."]
    pub fn to_ordinal_assume_zero(&self) -> Ordinal {
        let this = self;
        let this: &crate::Month = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Month::to_ordinal_assume_zero(this)) }
    }
    #[doc = " Return the owned types of this value."]
    pub fn get(&self) -> UMonth {
        let this = self;
        let this: &crate::Month = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Month::get(this)) }
    }
}
#[doc = " A value representing a day of a year in a leap year."]
#[cfg_attr(feature = "c", repr(transparent))]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pyclass)]
#[derive(Clone)]
pub struct Ordinal(UOrdinal);
#[cfg_attr(feature = "py", pymethods)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Ordinal {
    #[doc = " Return the owned types of this value."]
    pub fn get(&self) -> UOrdinal {
        let this = self;
        let this: &crate::Ordinal = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Ordinal::get(this)) }
    }
}
#[doc = " The base year counter type for Jalali calendar (no 0 variant)."]
#[cfg_attr(feature = "c", repr(transparent))]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pyclass)]
#[derive(Clone)]
pub struct Year(IYear);
#[cfg_attr(feature = "py", pymethods)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Year {
    #[doc = " A search into [`Self::NON_LEAP_CORRECTION`]."]
    pub fn is_no_leap_correction(&self) -> bool {
        let this = self;
        let this: &crate::Year = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Year::is_no_leap_correction(this)) }
    }
    #[doc = " Is this year a leap year (366 days instead of 365).\n\n Calculated using the 33-year rule. Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L161C1-L173C2>"]
    pub fn is_leap(&self) -> bool {
        let this = self;
        let this: &crate::Year = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Year::is_leap(this)) }
    }
    #[doc = " Return the number of the maximum consecutive day of the year (365 or 366 for leaps)."]
    pub fn max_ordinal(&self) -> Ordinal {
        let this = self;
        let this: &crate::Year = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Year::max_ordinal(this)) }
    }
    #[doc = " Return the owned types of this value."]
    pub fn get(&self) -> IYear {
        let this = self;
        let this: &crate::Year = &this.clone().into();
        unsafe { ::core::mem::transmute(crate::Year::get(this)) }
    }
}
#[cfg(feature = "py")]
#[pymodule(name = "jelal")]
fn __pymodule(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(_year_get, m)?)?;
    m.add_function(wrap_pyfunction!(_year_max_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_year_is_leap, m)?)?;
    m.add_function(wrap_pyfunction!(_year_is_no_leap_correction, m)?)?;
    m.add_function(wrap_pyfunction!(_year_new, m)?)?;
    m.add_class::<Year>()?;
    m.add_function(wrap_pyfunction!(_ordinal_get, m)?)?;
    m.add_function(wrap_pyfunction!(_ordinal_new, m)?)?;
    m.add_class::<Ordinal>()?;
    m.add_function(wrap_pyfunction!(_month_get, m)?)?;
    m.add_function(wrap_pyfunction!(_month_new, m)?)?;
    m.add_function(wrap_pyfunction!(_month_to_ordinal_assume_zero, m)?)?;
    m.add_class::<Month>()?;
    m.add_function(wrap_pyfunction!(_date_ext_from_iyear, m)?)?;
    m.add_function(wrap_pyfunction!(_date_ext_from_year, m)?)?;
    m.add_function(wrap_pyfunction!(_date_ext_cmp, m)?)?;
    m.add_function(wrap_pyfunction!(_date_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_date_year, m)?)?;
    m.add_function(wrap_pyfunction!(_date_diff_epoch, m)?)?;
    m.add_function(wrap_pyfunction!(_date_diff_as_days, m)?)?;
    m.add_function(wrap_pyfunction!(_date_add_days, m)?)?;
    m.add_function(wrap_pyfunction!(_date_add_months, m)?)?;
    m.add_function(wrap_pyfunction!(_date_add_month, m)?)?;
    m.add_function(wrap_pyfunction!(_date_add_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_date_add_year, m)?)?;
    m.add_function(wrap_pyfunction!(_date_new, m)?)?;
    m.add_class::<Date>()?;
    m.add_function(wrap_pyfunction!(_monthday_ext_from_date, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_ext_from_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_ext_cmp, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_day, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_month, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_from_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_add_day, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_add_month, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_to_ordinal, m)?)?;
    m.add_function(wrap_pyfunction!(_monthday_new, m)?)?;
    m.add_class::<MonthDay>()?;
    Ok(())
}
impl From<MonthDay> for crate::MonthDay {
    fn from(value: MonthDay) -> Self {
        Self {
            month: value.month.into(),
            day: value.day.into(),
        }
    }
}
impl From<crate::MonthDay> for MonthDay {
    fn from(value: crate::MonthDay) -> Self {
        Self {
            month: value.month.into(),
            day: value.day.into(),
        }
    }
}
#[doc = " The minimum possible day, the start of every month."]
pub const MONTHDAY_MIN_DAY: UMonthDay = crate::MonthDay::MIN_DAY;
#[doc = " The minimum possible day, the start of every month."]
#[unsafe(export_name = "MONTHDAY_MIN_DAY")]
pub static _MONTHDAY_MIN_DAY: UMonthDay = MONTHDAY_MIN_DAY;
#[doc = " The maximum day count of the year (for months prior to [`Month::MID`] or start of fall)."]
pub const MONTHDAY_MAX_DAY: UMonthDay = crate::MonthDay::MAX_DAY;
#[doc = " The maximum day count of the year (for months prior to [`Month::MID`] or start of fall)."]
#[unsafe(export_name = "MONTHDAY_MAX_DAY")]
pub static _MONTHDAY_MAX_DAY: UMonthDay = MONTHDAY_MAX_DAY;
#[doc = " The maximum number of days in a month post [`Month::MID`]."]
pub const MONTHDAY_POST_MID_MAX_DAY: UMonthDay = crate::MonthDay::POST_MID_MAX_DAY;
#[doc = " The maximum number of days in a month post [`Month::MID`]."]
#[unsafe(export_name = "MONTHDAY_POST_MID_MAX_DAY")]
pub static _MONTHDAY_POST_MID_MAX_DAY: UMonthDay = MONTHDAY_POST_MID_MAX_DAY;
#[doc = " The maximum of the last month in a non-leap year."]
pub const MONTHDAY_NON_LEAP_LAST_MAX_DAY: UMonthDay = crate::MonthDay::NON_LEAP_LAST_MAX_DAY;
#[doc = " The maximum of the last month in a non-leap year."]
#[unsafe(export_name = "MONTHDAY_NON_LEAP_LAST_MAX_DAY")]
pub static _MONTHDAY_NON_LEAP_LAST_MAX_DAY: UMonthDay = MONTHDAY_NON_LEAP_LAST_MAX_DAY;
#[doc = " Deprecated: use [`Self::NON_LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a non-leap year."]
#[deprecated(since = "0.4.1", note = "use [`Self::NON_LEAP_LAST_MAX_DAY`] instead")]
pub const MONTHDAY_NON_LEAP_LAST_MONTH_DAY_MAX: UMonthDay =
    crate::MonthDay::NON_LEAP_LAST_MONTH_DAY_MAX;
#[doc = " Deprecated: use [`Self::NON_LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a non-leap year."]
#[deprecated(since = "0.4.1", note = "use [`Self::NON_LEAP_LAST_MAX_DAY`] instead")]
#[unsafe(export_name = "MONTHDAY_NON_LEAP_LAST_MONTH_DAY_MAX")]
pub static _MONTHDAY_NON_LEAP_LAST_MONTH_DAY_MAX: UMonthDay = MONTHDAY_NON_LEAP_LAST_MONTH_DAY_MAX;
#[doc = " The maximum of the last month in a leap year."]
pub const MONTHDAY_LEAP_LAST_MAX_DAY: UMonthDay = crate::MonthDay::LEAP_LAST_MAX_DAY;
#[doc = " The maximum of the last month in a leap year."]
#[unsafe(export_name = "MONTHDAY_LEAP_LAST_MAX_DAY")]
pub static _MONTHDAY_LEAP_LAST_MAX_DAY: UMonthDay = MONTHDAY_LEAP_LAST_MAX_DAY;
#[doc = " Deprecated: use [`Self::LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a leap year."]
#[deprecated(since = "0.4.1", note = "use [`Self::LEAP_LAST_MAX_DAY`] instead")]
pub const MONTHDAY_LEAP_LAST_MONTH_DAY_MAX: UMonthDay = crate::MonthDay::LEAP_LAST_MONTH_DAY_MAX;
#[doc = " Deprecated: use [`Self::LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a leap year."]
#[deprecated(since = "0.4.1", note = "use [`Self::LEAP_LAST_MAX_DAY`] instead")]
#[unsafe(export_name = "MONTHDAY_LEAP_LAST_MONTH_DAY_MAX")]
pub static _MONTHDAY_LEAP_LAST_MONTH_DAY_MAX: UMonthDay = MONTHDAY_LEAP_LAST_MONTH_DAY_MAX;
#[doc = " The day of month in Jalali for Unix Epoch."]
pub const MONTHDAY_EPOCH_DAY: UMonthDay = crate::MonthDay::EPOCH_DAY;
#[doc = " The day of month in Jalali for Unix Epoch."]
#[unsafe(export_name = "MONTHDAY_EPOCH_DAY")]
pub static _MONTHDAY_EPOCH_DAY: UMonthDay = MONTHDAY_EPOCH_DAY;
#[doc = " The minimum valid this inner type, everything saturates to this if less."]
pub const MONTHDAY_MIN: MonthDay = MonthDay {
    month: Month::MIN,
    day: crate::MonthDay::MIN_DAY,
};
#[doc = " The minimum valid this inner type, everything saturates to this if less."]
#[unsafe(export_name = "MONTHDAY_MIN")]
pub static _MONTHDAY_MIN: MonthDay = MONTHDAY_MIN;
#[doc = " The maxmium valid this inner type, everything saturates to this if greater."]
pub const MONTHDAY_MAX: MonthDay = MonthDay {
    month: Month::MAX,
    day: crate::MonthDay::LEAP_LAST_MAX_DAY,
};
#[doc = " The maxmium valid this inner type, everything saturates to this if greater."]
#[unsafe(export_name = "MONTHDAY_MAX")]
pub static _MONTHDAY_MAX: MonthDay = MONTHDAY_MAX;
#[doc = " Unix Epoch in this format."]
pub const MONTHDAY_EPOCH: MonthDay = MonthDay {
    month: Month::EPOCH,
    day: crate::MonthDay::EPOCH_DAY,
};
#[doc = " Unix Epoch in this format."]
#[unsafe(export_name = "MONTHDAY_EPOCH")]
pub static _MONTHDAY_EPOCH: MonthDay = MONTHDAY_EPOCH;
#[doc = " Create a new valid instance and slightly saturate and modify to fit a valid instance."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_new(month: UMonth, day: UMonthDay) -> MonthDay {
    MonthDay::new(month.into(), day.into()).into()
}
#[doc = " Create a new valid instance and slightly saturate and modify to fit a valid instance."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_new(month: UMonth, day: UMonthDay) -> MonthDay {
    MonthDay::new(month.into(), day.into()).into()
}
#[doc = " Return the ordinal (day of the year) for this month and its day."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_to_ordinal(this: &MonthDay) -> UOrdinal {
    MonthDay::to_ordinal(&this.clone().into()).into()
}
#[doc = " Return the ordinal (day of the year) for this month and its day."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_to_ordinal(this: &MonthDay) -> UOrdinal {
    MonthDay::to_ordinal(&this.clone().into()).into()
}
#[doc = " Add or sub a value to this month and saturate to the limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_add_month(this: MonthDay, month: IMonth) -> MonthDay {
    MonthDay::add_month(this.into(), month.into()).into()
}
#[doc = " Add or sub a value to this month and saturate to the limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_add_month(this: MonthDay, month: IMonth) -> MonthDay {
    MonthDay::add_month(this.into(), month.into()).into()
}
#[doc = " Add or sub a value to the day of this and saturate to the limits.\n\n This is exactly as [`Self::add_day_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_add_day(this: MonthDay, day: IMonthDay) -> MonthDay {
    MonthDay::add_day(this.into(), day.into()).into()
}
#[doc = " Add or sub a value to the day of this and saturate to the limits.\n\n This is exactly as [`Self::add_day_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_add_day(this: MonthDay, day: IMonthDay) -> MonthDay {
    MonthDay::add_day(this.into(), day.into()).into()
}
#[doc = " Create a valid month and day (in order) from a valid day of the year."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_from_ordinal(value: UOrdinal) -> MonthDay {
    MonthDay::from_ordinal(value.into()).into()
}
#[doc = " Create a valid month and day (in order) from a valid day of the year."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_from_ordinal(value: UOrdinal) -> MonthDay {
    MonthDay::from_ordinal(value.into()).into()
}
#[doc = " Return the value of inner `Self::month` for this instance."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_month(this: &MonthDay) -> UMonth {
    MonthDay::month(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::month` for this instance."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_month(this: &MonthDay) -> UMonth {
    MonthDay::month(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::day` for this instance."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_day(this: &MonthDay) -> UMonthDay {
    MonthDay::day(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::day` for this instance."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_day(this: &MonthDay) -> UMonthDay {
    MonthDay::day(&this.clone().into()).into()
}
#[cfg_attr(feature = "py", pymethods)]
impl MonthDay {
    #[doc = " The minimum possible day, the start of every month."]
    pub const MIN_DAY: UMonthDay = crate::MonthDay::MIN_DAY;
    #[doc = " The maximum day count of the year (for months prior to [`Month::MID`] or start of fall)."]
    pub const MAX_DAY: UMonthDay = crate::MonthDay::MAX_DAY;
    #[doc = " The maximum number of days in a month post [`Month::MID`]."]
    pub const POST_MID_MAX_DAY: UMonthDay = crate::MonthDay::POST_MID_MAX_DAY;
    #[doc = " The maximum of the last month in a non-leap year."]
    pub const NON_LEAP_LAST_MAX_DAY: UMonthDay = crate::MonthDay::NON_LEAP_LAST_MAX_DAY;
    #[doc = " Deprecated: use [`Self::NON_LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a non-leap year."]
    #[deprecated(since = "0.4.1", note = "use [`Self::NON_LEAP_LAST_MAX_DAY`] instead")]
    pub const NON_LEAP_LAST_MONTH_DAY_MAX: UMonthDay = crate::MonthDay::NON_LEAP_LAST_MONTH_DAY_MAX;
    #[doc = " The maximum of the last month in a leap year."]
    pub const LEAP_LAST_MAX_DAY: UMonthDay = crate::MonthDay::LEAP_LAST_MAX_DAY;
    #[doc = " Deprecated: use [`Self::LEAP_LAST_MAX_DAY`] instead (since `0.4.1`).\n\n The maximum of the last month in a leap year."]
    #[deprecated(since = "0.4.1", note = "use [`Self::LEAP_LAST_MAX_DAY`] instead")]
    pub const LEAP_LAST_MONTH_DAY_MAX: UMonthDay = crate::MonthDay::LEAP_LAST_MONTH_DAY_MAX;
    #[doc = " The day of month in Jalali for Unix Epoch."]
    pub const EPOCH_DAY: UMonthDay = crate::MonthDay::EPOCH_DAY;
    #[doc = " The minimum valid this inner type, everything saturates to this if less."]
    pub const MIN: Self = MonthDay {
        month: Month::MIN,
        day: crate::MonthDay::MIN_DAY,
    };
    #[doc = " The maxmium valid this inner type, everything saturates to this if greater."]
    pub const MAX: Self = MonthDay {
        month: Month::MAX,
        day: crate::MonthDay::LEAP_LAST_MAX_DAY,
    };
    #[doc = " Unix Epoch in this format."]
    pub const EPOCH: Self = MonthDay {
        month: Month::EPOCH,
        day: crate::MonthDay::EPOCH_DAY,
    };
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl MonthDay {
    #[doc = " Add or sub a value to this month and saturate to the limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
    pub fn add_month(self, month: IMonth) -> MonthDay {
        let this = self;
        let this: crate::MonthDay = this.into();
        unsafe { ::core::mem::transmute(crate::MonthDay::add_month(this, month.into())) }
    }
    #[doc = " Add or sub a value to the day of this and saturate to the limits.\n\n This is exactly as [`Self::add_day_strict`] but returns the value only."]
    pub fn add_day(self, day: IMonthDay) -> MonthDay {
        let this = self;
        let this: crate::MonthDay = this.into();
        unsafe { ::core::mem::transmute(crate::MonthDay::add_day(this, day.into())) }
    }
    #[doc = " Create a valid month and day (in order) from a valid day of the year."]
    pub fn from_ordinal(value: UOrdinal) -> MonthDay {
        unsafe { ::core::mem::transmute(crate::MonthDay::from_ordinal(value.into())) }
    }
    #[cfg_attr(feature = "wasm", wasm_bindgen(constructor))]
    #[doc = " Create a new valid instance and slightly saturate and modify to fit a valid instance."]
    pub fn new(month: UMonth, day: UMonthDay) -> MonthDay {
        unsafe { ::core::mem::transmute(crate::MonthDay::new(month.into(), day.into())) }
    }
}
#[cfg(feature = "py")]
#[pymethods]
impl MonthDay {
    #[doc = " Add or sub a value to this month and saturate to the limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_month")]
    fn __py_only_add_month(&self, month: IMonth) -> MonthDay {
        let this = self;
        let this: Self = this.clone();
        let this: crate::MonthDay = this.into();
        unsafe { ::core::mem::transmute(crate::MonthDay::add_month(this, month.into())) }
    }
    #[doc = " Add or sub a value to the day of this and saturate to the limits.\n\n This is exactly as [`Self::add_day_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_day")]
    fn __py_only_add_day(&self, day: IMonthDay) -> MonthDay {
        let this = self;
        let this: Self = this.clone();
        let this: crate::MonthDay = this.into();
        unsafe { ::core::mem::transmute(crate::MonthDay::add_day(this, day.into())) }
    }
    #[doc = " Create a valid month and day (in order) from a valid day of the year."]
    #[cfg(feature = "py")]
    #[pyo3(name = "from_ordinal")]
    #[staticmethod]
    fn __py_only_from_ordinal(value: UOrdinal) -> MonthDay {
        unsafe { ::core::mem::transmute(crate::MonthDay::from_ordinal(value.into())) }
    }
    #[cfg(feature = "py")]
    #[new]
    #[doc = " Create a new valid instance and slightly saturate and modify to fit a valid instance."]
    pub fn __py_only_new(month: UMonth, day: UMonthDay) -> MonthDay {
        unsafe { ::core::mem::transmute(crate::MonthDay::new(month.into(), day.into())) }
    }
}
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_ext_cmp(this: &MonthDay, other: &MonthDay) -> i8 {
    MonthDay::ext_cmp(&this.clone().into(), &other.clone().into()).into()
}
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_ext_cmp(this: &MonthDay, other: &MonthDay) -> i8 {
    MonthDay::ext_cmp(&this.clone().into(), &other.clone().into()).into()
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pymethods)]
impl MonthDay {
    pub fn ext_cmp(&self, other: &Self) -> i8 {
        crate::MonthDay::from(self.clone()).cmp(&crate::MonthDay::from(other.clone())) as i8
    }
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_ext_from_ordinal(value: UOrdinal) -> MonthDay {
    MonthDay::ext_from_ordinal(value.into()).into()
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_ext_from_ordinal(value: UOrdinal) -> MonthDay {
    MonthDay::ext_from_ordinal(value.into()).into()
}
#[cfg(feature = "py")]
#[pymethods]
impl MonthDay {
    #[doc = " FFI version of a `From` trait implementation"]
    #[cfg(feature = "py")]
    #[staticmethod]
    #[pyo3(name = "ext_from_ordinal")]
    pub fn __py_only_ext_from_ordinal(value: Ordinal) -> Self {
        crate::MonthDay::from(crate::Ordinal::from(value)).into()
    }
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl MonthDay {
    #[doc = " FFI version of a `From` trait implementation"]
    pub fn ext_from_ordinal(value: Ordinal) -> Self {
        crate::MonthDay::from(crate::Ordinal::from(value)).into()
    }
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn monthday_ext_from_date(value: Date) -> MonthDay {
    MonthDay::ext_from_date(value.into()).into()
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _monthday_ext_from_date(value: Date) -> MonthDay {
    MonthDay::ext_from_date(value.into()).into()
}
#[cfg(feature = "py")]
#[pymethods]
impl MonthDay {
    #[doc = " FFI version of a `From` trait implementation"]
    #[cfg(feature = "py")]
    #[staticmethod]
    #[pyo3(name = "ext_from_date")]
    pub fn __py_only_ext_from_date(value: Date) -> Self {
        crate::MonthDay::from(crate::Date::from(value)).into()
    }
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl MonthDay {
    #[doc = " FFI version of a `From` trait implementation"]
    pub fn ext_from_date(value: Date) -> Self {
        crate::MonthDay::from(crate::Date::from(value)).into()
    }
}
impl From<Date> for crate::Date {
    fn from(value: Date) -> Self {
        Self {
            year: value.year.into(),
            ordinal: value.ordinal.into(),
        }
    }
}
impl From<crate::Date> for Date {
    fn from(value: crate::Date) -> Self {
        Self {
            year: value.year.into(),
            ordinal: value.ordinal.into(),
        }
    }
}
#[doc = " The furthest in the past that can be represented with this struct."]
pub const DATE_MIN: Date = Date {
    year: Year::MIN,
    ordinal: Ordinal::MIN,
};
#[doc = " The furthest in the past that can be represented with this struct."]
#[unsafe(export_name = "DATE_MIN")]
pub static _DATE_MIN: Date = DATE_MIN;
#[doc = " The furthest in the future that can be represented with this struct."]
pub const DATE_MAX: Date = Date {
    year: Year::MAX,
    ordinal: Ordinal::MAX,
};
#[doc = " The furthest in the future that can be represented with this struct."]
#[unsafe(export_name = "DATE_MAX")]
pub static _DATE_MAX: Date = DATE_MAX;
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January [`MonthDay`], 1970)."]
pub const DATE_EPOCH: Date = Date {
    year: Year::EPOCH,
    ordinal: Ordinal::EPOCH,
};
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January [`MonthDay`], 1970)."]
#[unsafe(export_name = "DATE_EPOCH")]
pub static _DATE_EPOCH: Date = DATE_EPOCH;
#[doc = " Create a new Jalali date or slightly change values to be valid."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_new(year: IYear, ordinal: UOrdinal) -> Date {
    Date::new(year.into(), ordinal.into()).into()
}
#[doc = " Create a new Jalali date or slightly change values to be valid."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_new(year: IYear, ordinal: UOrdinal) -> Date {
    Date::new(year.into(), ordinal.into()).into()
}
#[doc = " Add a year to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_year_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_add_year(this: Date, year: IYear) -> Date {
    Date::add_year(this.into(), year.into()).into()
}
#[doc = " Add a year to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_year_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_add_year(this: Date, year: IYear) -> Date {
    Date::add_year(this.into(), year.into()).into()
}
#[doc = " Add a ordinal to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_ordinal_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_add_ordinal(this: Date, ordinal: IOrdinal) -> Date {
    Date::add_ordinal(this.into(), ordinal.into()).into()
}
#[doc = " Add a ordinal to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_ordinal_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_add_ordinal(this: Date, ordinal: IOrdinal) -> Date {
    Date::add_ordinal(this.into(), ordinal.into()).into()
}
#[doc = " Add a month count to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_add_month(this: Date, month: IMonth) -> Date {
    Date::add_month(this.into(), month.into()).into()
}
#[doc = " Add a month count to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_add_month(this: Date, month: IMonth) -> Date {
    Date::add_month(this.into(), month.into()).into()
}
#[doc = " Add this many consecutive months to this date.\n\n This is exactly as [`Self::add_months_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_add_months(this: Date, months: IDayDiff) -> Date {
    Date::add_months(this.into(), months.into()).into()
}
#[doc = " Add this many consecutive months to this date.\n\n This is exactly as [`Self::add_months_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_add_months(this: Date, months: IDayDiff) -> Date {
    Date::add_months(this.into(), months.into()).into()
}
#[doc = " Add or remove the given number of consecutive days to this date.\n\n This is exactly as [`Self::add_days_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_add_days(this: Date, days: IDayDiff) -> Date {
    Date::add_days(this.into(), days.into()).into()
}
#[doc = " Add or remove the given number of consecutive days to this date.\n\n This is exactly as [`Self::add_days_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_add_days(this: Date, days: IDayDiff) -> Date {
    Date::add_days(this.into(), days.into()).into()
}
#[doc = " Return how many days on this date will result to the given destination.\n\n This is exactly as [`Self::diff_as_days_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_diff_as_days(this: &Date, other: Date) -> IDayDiff {
    Date::diff_as_days(&this.clone().into(), other.into()).into()
}
#[doc = " Return how many days on this date will result to the given destination.\n\n This is exactly as [`Self::diff_as_days_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_diff_as_days(this: &Date, other: Date) -> IDayDiff {
    Date::diff_as_days(&this.clone().into(), other.into()).into()
}
#[doc = " Return how many days has passed since or is yet to reach [`Self::EPOCH`].\n\n This is exactly as [`Self::diff_epoch_strict`] but returns the value only."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_diff_epoch(this: &Date) -> IDayDiff {
    Date::diff_epoch(&this.clone().into()).into()
}
#[doc = " Return how many days has passed since or is yet to reach [`Self::EPOCH`].\n\n This is exactly as [`Self::diff_epoch_strict`] but returns the value only."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_diff_epoch(this: &Date) -> IDayDiff {
    Date::diff_epoch(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::year` for this instance."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_year(this: &Date) -> IYear {
    Date::year(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::year` for this instance."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_year(this: &Date) -> IYear {
    Date::year(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::ordinal` for this instance."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_ordinal(this: &Date) -> UOrdinal {
    Date::ordinal(&this.clone().into()).into()
}
#[doc = " Return the value of inner `Self::ordinal` for this instance."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_ordinal(this: &Date) -> UOrdinal {
    Date::ordinal(&this.clone().into()).into()
}
#[cfg_attr(feature = "py", pymethods)]
impl Date {
    #[doc = " The furthest in the past that can be represented with this struct."]
    pub const MIN: Self = Date {
        year: Year::MIN,
        ordinal: Ordinal::MIN,
    };
    #[doc = " The furthest in the future that can be represented with this struct."]
    pub const MAX: Self = Date {
        year: Year::MAX,
        ordinal: Ordinal::MAX,
    };
    #[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January [`MonthDay`], 1970)."]
    pub const EPOCH: Self = Date {
        year: Year::EPOCH,
        ordinal: Ordinal::EPOCH,
    };
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Date {
    #[doc = " Add a year to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_year_strict`] but returns the value only."]
    pub fn add_year(self, year: IYear) -> Date {
        let this = self;
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_year(this, year.into())) }
    }
    #[doc = " Add a ordinal to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_ordinal_strict`] but returns the value only."]
    pub fn add_ordinal(self, ordinal: IOrdinal) -> Date {
        let this = self;
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_ordinal(this, ordinal.into())) }
    }
    #[doc = " Add a month count to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
    pub fn add_month(self, month: IMonth) -> Date {
        let this = self;
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_month(this, month.into())) }
    }
    #[doc = " Add this many consecutive months to this date.\n\n This is exactly as [`Self::add_months_strict`] but returns the value only."]
    pub fn add_months(self, months: IDayDiff) -> Date {
        let this = self;
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_months(this, months.into())) }
    }
    #[doc = " Add or remove the given number of consecutive days to this date.\n\n This is exactly as [`Self::add_days_strict`] but returns the value only."]
    pub fn add_days(self, days: IDayDiff) -> Date {
        let this = self;
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_days(this, days.into())) }
    }
    #[cfg_attr(feature = "wasm", wasm_bindgen(constructor))]
    #[doc = " Create a new Jalali date or slightly change values to be valid."]
    pub fn new(year: IYear, ordinal: UOrdinal) -> Date {
        unsafe { ::core::mem::transmute(crate::Date::new(year.into(), ordinal.into())) }
    }
}
#[cfg(feature = "py")]
#[pymethods]
impl Date {
    #[doc = " Add a year to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_year_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_year")]
    fn __py_only_add_year(&self, year: IYear) -> Date {
        let this = self;
        let this: Self = this.clone();
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_year(this, year.into())) }
    }
    #[doc = " Add a ordinal to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_ordinal_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_ordinal")]
    fn __py_only_add_ordinal(&self, ordinal: IOrdinal) -> Date {
        let this = self;
        let this: Self = this.clone();
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_ordinal(this, ordinal.into())) }
    }
    #[doc = " Add a month count to this date and saturate the results at limits.\n\n This is exactly as [`Self::add_month_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_month")]
    fn __py_only_add_month(&self, month: IMonth) -> Date {
        let this = self;
        let this: Self = this.clone();
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_month(this, month.into())) }
    }
    #[doc = " Add this many consecutive months to this date.\n\n This is exactly as [`Self::add_months_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_months")]
    fn __py_only_add_months(&self, months: IDayDiff) -> Date {
        let this = self;
        let this: Self = this.clone();
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_months(this, months.into())) }
    }
    #[doc = " Add or remove the given number of consecutive days to this date.\n\n This is exactly as [`Self::add_days_strict`] but returns the value only."]
    #[cfg(feature = "py")]
    #[pyo3(name = "add_days")]
    fn __py_only_add_days(&self, days: IDayDiff) -> Date {
        let this = self;
        let this: Self = this.clone();
        let this: crate::Date = this.into();
        unsafe { ::core::mem::transmute(crate::Date::add_days(this, days.into())) }
    }
    #[cfg(feature = "py")]
    #[new]
    #[doc = " Create a new Jalali date or slightly change values to be valid."]
    pub fn __py_only_new(year: IYear, ordinal: UOrdinal) -> Date {
        unsafe { ::core::mem::transmute(crate::Date::new(year.into(), ordinal.into())) }
    }
}
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_ext_cmp(this: &Date, other: &Date) -> i8 {
    Date::ext_cmp(&this.clone().into(), &other.clone().into()).into()
}
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_ext_cmp(this: &Date, other: &Date) -> i8 {
    Date::ext_cmp(&this.clone().into(), &other.clone().into()).into()
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
#[cfg_attr(feature = "py", pymethods)]
impl Date {
    pub fn ext_cmp(&self, other: &Self) -> i8 {
        crate::Date::from(self.clone()).cmp(&crate::Date::from(other.clone())) as i8
    }
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_ext_from_year(value: IYear) -> Date {
    Date::ext_from_year(value.into()).into()
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_ext_from_year(value: IYear) -> Date {
    Date::ext_from_year(value.into()).into()
}
#[cfg(feature = "py")]
#[pymethods]
impl Date {
    #[doc = " FFI version of a `From` trait implementation"]
    #[cfg(feature = "py")]
    #[staticmethod]
    #[pyo3(name = "ext_from_year")]
    pub fn __py_only_ext_from_year(value: Year) -> Self {
        crate::Date::from(crate::Year::from(value)).into()
    }
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Date {
    #[doc = " FFI version of a `From` trait implementation"]
    pub fn ext_from_year(value: Year) -> Self {
        crate::Date::from(crate::Year::from(value)).into()
    }
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn date_ext_from_iyear(value: IYear) -> Date {
    Date::ext_from_iyear(value.into()).into()
}
#[doc = " FFI version of a `From` trait implementation"]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _date_ext_from_iyear(value: IYear) -> Date {
    Date::ext_from_iyear(value.into()).into()
}
#[cfg(feature = "py")]
#[pymethods]
impl Date {
    #[doc = " FFI version of a `From` trait implementation"]
    #[cfg(feature = "py")]
    #[staticmethod]
    #[pyo3(name = "ext_from_iyear")]
    pub fn __py_only_ext_from_iyear(value: IYear) -> Self {
        crate::Date::from(crate::IYear::from(value)).into()
    }
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Date {
    #[doc = " FFI version of a `From` trait implementation"]
    pub fn ext_from_iyear(value: IYear) -> Self {
        crate::Date::from(crate::IYear::from(value)).into()
    }
}
impl From<Month> for crate::Month {
    fn from(value: Month) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<crate::Month> for Month {
    fn from(value: crate::Month) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<UMonth> for Month {
    fn from(value: UMonth) -> Self {
        crate::Month::from(value).into()
    }
}
impl Into<UMonth> for Month {
    fn into(self) -> UMonth {
        crate::Month::from(self).into()
    }
}
#[doc = " Unix Epoch in this format (equivalent to Gregorian January (1st) in 1970, [`Year::EPOCH`])."]
pub const MONTH_EPOCH: UMonth = unsafe { ::core::mem::transmute(crate::Month::EPOCH) };
#[doc = " Unix Epoch in this format (equivalent to Gregorian January (1st) in 1970, [`Year::EPOCH`])."]
#[unsafe(export_name = "MONTH_EPOCH")]
pub static _MONTH_EPOCH: UMonth = MONTH_EPOCH;
#[doc = " The first month of the Jalali year; 1: Farvardin."]
pub const MONTH_MIN: UMonth = unsafe { ::core::mem::transmute(crate::Month::MIN) };
#[doc = " The first month of the Jalali year; 1: Farvardin."]
#[unsafe(export_name = "MONTH_MIN")]
pub static _MONTH_MIN: UMonth = MONTH_MIN;
#[doc = " The start of the second half of the year in months."]
pub const MONTH_MID: UMonth = unsafe { ::core::mem::transmute(crate::Month::MID) };
#[doc = " The start of the second half of the year in months."]
#[unsafe(export_name = "MONTH_MID")]
pub static _MONTH_MID: UMonth = MONTH_MID;
#[doc = " The last month of the Jalali year; 12: Esfand."]
pub const MONTH_MAX: UMonth = unsafe { ::core::mem::transmute(crate::Month::MAX) };
#[doc = " The last month of the Jalali year; 12: Esfand."]
#[unsafe(export_name = "MONTH_MAX")]
pub static _MONTH_MAX: UMonth = MONTH_MAX;
#[doc = " Convert a valid month to ordinal assuming 0th day of the month (-1) if month is valid."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn month_to_ordinal_assume_zero(this: UMonth) -> UOrdinal {
    let this: Month = this.into();
    Month::to_ordinal_assume_zero(&this).into()
}
#[doc = " Convert a valid month to ordinal assuming 0th day of the month (-1) if month is valid."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _month_to_ordinal_assume_zero(this: UMonth) -> UOrdinal {
    let this: Month = this.into();
    Month::to_ordinal_assume_zero(&this).into()
}
#[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn month_new(value: UMonth) -> UMonth {
    Month::new(value.into()).into()
}
#[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _month_new(value: UMonth) -> UMonth {
    Month::new(value.into()).into()
}
#[doc = " Return the owned types of this value."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn month_get(this: UMonth) -> UMonth {
    let this: Month = this.into();
    Month::get(&this).into()
}
#[doc = " Return the owned types of this value."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _month_get(this: UMonth) -> UMonth {
    let this: Month = this.into();
    Month::get(&this).into()
}
#[cfg_attr(feature = "py", pymethods)]
impl Month {
    #[doc = " Unix Epoch in this format (equivalent to Gregorian January (1st) in 1970, [`Year::EPOCH`])."]
    pub const EPOCH: Self = unsafe { ::core::mem::transmute(crate::Month::EPOCH) };
    #[doc = " The first month of the Jalali year; 1: Farvardin."]
    pub const MIN: Self = unsafe { ::core::mem::transmute(crate::Month::MIN) };
    #[doc = " The start of the second half of the year in months."]
    pub const MID: Self = unsafe { ::core::mem::transmute(crate::Month::MID) };
    #[doc = " The last month of the Jalali year; 12: Esfand."]
    pub const MAX: Self = unsafe { ::core::mem::transmute(crate::Month::MAX) };
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Month {
    #[cfg_attr(feature = "wasm", wasm_bindgen(constructor))]
    #[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
    pub fn new(value: UMonth) -> Month {
        unsafe { ::core::mem::transmute(crate::Month::new(value.into())) }
    }
}
#[cfg(feature = "py")]
#[pymethods]
impl Month {
    #[cfg(feature = "py")]
    #[new]
    #[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
    pub fn __py_only_new(value: UMonth) -> Month {
        unsafe { ::core::mem::transmute(crate::Month::new(value.into())) }
    }
}
impl From<Ordinal> for crate::Ordinal {
    fn from(value: Ordinal) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<crate::Ordinal> for Ordinal {
    fn from(value: crate::Ordinal) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<UOrdinal> for Ordinal {
    fn from(value: UOrdinal) -> Self {
        crate::Ordinal::from(value).into()
    }
}
impl Into<UOrdinal> for Ordinal {
    fn into(self) -> UOrdinal {
        crate::Ordinal::from(self).into()
    }
}
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January, 1970, [`Year::EPOCH`])."]
pub const ORDINAL_EPOCH: UOrdinal = unsafe { ::core::mem::transmute(crate::Ordinal::EPOCH) };
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January, 1970, [`Year::EPOCH`])."]
#[unsafe(export_name = "ORDINAL_EPOCH")]
pub static _ORDINAL_EPOCH: UOrdinal = ORDINAL_EPOCH;
#[doc = " Marks the first day of the year for a valid calendar year (this struct starts from 1)."]
pub const ORDINAL_MIN: UOrdinal = unsafe { ::core::mem::transmute(crate::Ordinal::MIN) };
#[doc = " Marks the first day of the year for a valid calendar year (this struct starts from 1)."]
#[unsafe(export_name = "ORDINAL_MIN")]
pub static _ORDINAL_MIN: UOrdinal = ORDINAL_MIN;
#[doc = " The first day after the sixth month of the year (first day of [`Month::MID`])."]
pub const ORDINAL_MID: UOrdinal = unsafe { ::core::mem::transmute(crate::Ordinal::MID) };
#[doc = " The first day after the sixth month of the year (first day of [`Month::MID`])."]
#[unsafe(export_name = "ORDINAL_MID")]
pub static _ORDINAL_MID: UOrdinal = ORDINAL_MID;
#[doc = " The absolute maximum day count for any year (leap, 366)."]
pub const ORDINAL_MAX: UOrdinal = unsafe { ::core::mem::transmute(crate::Ordinal::MAX) };
#[doc = " The absolute maximum day count for any year (leap, 366)."]
#[unsafe(export_name = "ORDINAL_MAX")]
pub static _ORDINAL_MAX: UOrdinal = ORDINAL_MAX;
#[doc = " The maximum day count for a non-leap year (365)."]
pub const ORDINAL_MAX_NON_LEAP: UOrdinal =
    unsafe { ::core::mem::transmute(crate::Ordinal::MAX_NON_LEAP) };
#[doc = " The maximum day count for a non-leap year (365)."]
#[unsafe(export_name = "ORDINAL_MAX_NON_LEAP")]
pub static _ORDINAL_MAX_NON_LEAP: UOrdinal = ORDINAL_MAX_NON_LEAP;
#[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn ordinal_new(value: UOrdinal) -> UOrdinal {
    Ordinal::new(value.into()).into()
}
#[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _ordinal_new(value: UOrdinal) -> UOrdinal {
    Ordinal::new(value.into()).into()
}
#[doc = " Return the owned types of this value."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn ordinal_get(this: UOrdinal) -> UOrdinal {
    let this: Ordinal = this.into();
    Ordinal::get(&this).into()
}
#[doc = " Return the owned types of this value."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _ordinal_get(this: UOrdinal) -> UOrdinal {
    let this: Ordinal = this.into();
    Ordinal::get(&this).into()
}
#[cfg_attr(feature = "py", pymethods)]
impl Ordinal {
    #[doc = " Unix Epoch in this format (equivalent to Gregorian 1st of January, 1970, [`Year::EPOCH`])."]
    pub const EPOCH: Self = unsafe { ::core::mem::transmute(crate::Ordinal::EPOCH) };
    #[doc = " Marks the first day of the year for a valid calendar year (this struct starts from 1)."]
    pub const MIN: Self = unsafe { ::core::mem::transmute(crate::Ordinal::MIN) };
    #[doc = " The first day after the sixth month of the year (first day of [`Month::MID`])."]
    pub const MID: Self = unsafe { ::core::mem::transmute(crate::Ordinal::MID) };
    #[doc = " The absolute maximum day count for any year (leap, 366)."]
    pub const MAX: Self = unsafe { ::core::mem::transmute(crate::Ordinal::MAX) };
    #[doc = " The maximum day count for a non-leap year (365)."]
    pub const MAX_NON_LEAP: Self = unsafe { ::core::mem::transmute(crate::Ordinal::MAX_NON_LEAP) };
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Ordinal {
    #[cfg_attr(feature = "wasm", wasm_bindgen(constructor))]
    #[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
    pub fn new(value: UOrdinal) -> Ordinal {
        unsafe { ::core::mem::transmute(crate::Ordinal::new(value.into())) }
    }
}
#[cfg(feature = "py")]
#[pymethods]
impl Ordinal {
    #[cfg(feature = "py")]
    #[new]
    #[doc = " Create a new instance and limit it to [`Self::MIN`] and [`Self::MAX`]."]
    pub fn __py_only_new(value: UOrdinal) -> Ordinal {
        unsafe { ::core::mem::transmute(crate::Ordinal::new(value.into())) }
    }
}
impl From<Year> for crate::Year {
    fn from(value: Year) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<crate::Year> for Year {
    fn from(value: crate::Year) -> Self {
        Self { 0: value.0.into() }
    }
}
impl From<IYear> for Year {
    fn from(value: IYear) -> Self {
        crate::Year::from(value).into()
    }
}
impl Into<IYear> for Year {
    fn into(self) -> IYear {
        crate::Year::from(self).into()
    }
}
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1970)."]
pub const YEAR_EPOCH: IYear = unsafe { ::core::mem::transmute(crate::Year::EPOCH) };
#[doc = " Unix Epoch in this format (equivalent to Gregorian 1970)."]
#[unsafe(export_name = "YEAR_EPOCH")]
pub static _YEAR_EPOCH: IYear = YEAR_EPOCH;
#[doc = " The furthest year in the past possible for this struct."]
pub const YEAR_MIN: IYear = unsafe { ::core::mem::transmute(crate::Year::MIN) };
#[doc = " The furthest year in the past possible for this struct."]
#[unsafe(export_name = "YEAR_MIN")]
pub static _YEAR_MIN: IYear = YEAR_MIN;
#[doc = " The furthest year in the future possible for this struct."]
pub const YEAR_MAX: IYear = unsafe { ::core::mem::transmute(crate::Year::MAX) };
#[doc = " The furthest year in the future possible for this struct."]
#[unsafe(export_name = "YEAR_MAX")]
pub static _YEAR_MAX: IYear = YEAR_MAX;
#[doc = " The source of truth for the zero replacement value (-1 is before year 1, skipping 0)."]
pub const YEAR_ZERO_REPLACEMENT: IYear =
    unsafe { ::core::mem::transmute(crate::Year::ZERO_REPLACEMENT) };
#[doc = " The source of truth for the zero replacement value (-1 is before year 1, skipping 0)."]
#[unsafe(export_name = "YEAR_ZERO_REPLACEMENT")]
pub static _YEAR_ZERO_REPLACEMENT: IYear = YEAR_ZERO_REPLACEMENT;
#[doc = " Create a valid year and if 0, replace it with -1 ([`Self::ZERO_REPLACEMENT`] in effect)."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn year_new(value: IYear) -> IYear {
    Year::new(value.into()).into()
}
#[doc = " Create a valid year and if 0, replace it with -1 ([`Self::ZERO_REPLACEMENT`] in effect)."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _year_new(value: IYear) -> IYear {
    Year::new(value.into()).into()
}
#[doc = " Persian Wikipedia's list of leap years pre-calculated.\n\n NOTE Do not rely on this."]
pub const YEAR_LEAPS_1210_TO_1500: [IYear; 71] =
    unsafe { ::core::mem::transmute(crate::Year::LEAPS_1210_TO_1500) };
#[doc = " Persian Wikipedia's list of leap years pre-calculated.\n\n NOTE Do not rely on this."]
#[unsafe(export_name = "YEAR_LEAPS_1210_TO_1500")]
pub static _YEAR_LEAPS_1210_TO_1500: [IYear; 71] = YEAR_LEAPS_1210_TO_1500;
#[doc = " Years that are not leap while 33-year rule marks them as leap.\n\n \"All these years are not leap, while they are considered leap by the 33-year\n rule. The year following each of them is leap, but it's considered non-leap\n by the 33-year rule. This table has been tested to match the modified\n astronomical algorithm based on the 52.5 degrees east meridian from 1178 AP\n (an arbitrary date before the Persian calendar was adopted in 1304 AP) to\n 3000 AP (an arbitrary date far into the future).\"\n\n Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L23>"]
pub const YEAR_NON_LEAP_CORRECTION: [IYear; 78] =
    unsafe { ::core::mem::transmute(crate::Year::NON_LEAP_CORRECTION) };
#[doc = " Years that are not leap while 33-year rule marks them as leap.\n\n \"All these years are not leap, while they are considered leap by the 33-year\n rule. The year following each of them is leap, but it's considered non-leap\n by the 33-year rule. This table has been tested to match the modified\n astronomical algorithm based on the 52.5 degrees east meridian from 1178 AP\n (an arbitrary date before the Persian calendar was adopted in 1304 AP) to\n 3000 AP (an arbitrary date far into the future).\"\n\n Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L23>"]
#[unsafe(export_name = "YEAR_NON_LEAP_CORRECTION")]
pub static _YEAR_NON_LEAP_CORRECTION: [IYear; 78] = YEAR_NON_LEAP_CORRECTION;
#[doc = " A search into [`Self::NON_LEAP_CORRECTION`]."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn year_is_no_leap_correction(this: IYear) -> bool {
    let this: Year = this.into();
    Year::is_no_leap_correction(&this).into()
}
#[doc = " A search into [`Self::NON_LEAP_CORRECTION`]."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _year_is_no_leap_correction(this: IYear) -> bool {
    let this: Year = this.into();
    Year::is_no_leap_correction(&this).into()
}
#[doc = " Is this year a leap year (366 days instead of 365).\n\n Calculated using the 33-year rule. Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L161C1-L173C2>"]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn year_is_leap(this: IYear) -> bool {
    let this: Year = this.into();
    Year::is_leap(&this).into()
}
#[doc = " Is this year a leap year (366 days instead of 365).\n\n Calculated using the 33-year rule. Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L161C1-L173C2>"]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _year_is_leap(this: IYear) -> bool {
    let this: Year = this.into();
    Year::is_leap(&this).into()
}
#[doc = " Return the number of the maximum consecutive day of the year (365 or 366 for leaps)."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn year_max_ordinal(this: IYear) -> UOrdinal {
    let this: Year = this.into();
    Year::max_ordinal(&this).into()
}
#[doc = " Return the number of the maximum consecutive day of the year (365 or 366 for leaps)."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _year_max_ordinal(this: IYear) -> UOrdinal {
    let this: Year = this.into();
    Year::max_ordinal(&this).into()
}
#[doc = " Return the owned types of this value."]
#[cfg(feature = "c")]
#[unsafe(no_mangle)]
pub extern "C" fn year_get(this: IYear) -> IYear {
    let this: Year = this.into();
    Year::get(&this).into()
}
#[doc = " Return the owned types of this value."]
#[cfg_attr(feature = "py", pyfunction)]
#[cfg_attr(feature = "wasm", wasm_bindgen)]
pub fn _year_get(this: IYear) -> IYear {
    let this: Year = this.into();
    Year::get(&this).into()
}
#[cfg_attr(feature = "py", pymethods)]
impl Year {
    #[doc = " Unix Epoch in this format (equivalent to Gregorian 1970)."]
    pub const EPOCH: Self = unsafe { ::core::mem::transmute(crate::Year::EPOCH) };
    #[doc = " The furthest year in the past possible for this struct."]
    pub const MIN: Self = unsafe { ::core::mem::transmute(crate::Year::MIN) };
    #[doc = " The furthest year in the future possible for this struct."]
    pub const MAX: Self = unsafe { ::core::mem::transmute(crate::Year::MAX) };
    #[doc = " The source of truth for the zero replacement value (-1 is before year 1, skipping 0)."]
    pub const ZERO_REPLACEMENT: Self =
        unsafe { ::core::mem::transmute(crate::Year::ZERO_REPLACEMENT) };
    #[doc = " Persian Wikipedia's list of leap years pre-calculated.\n\n NOTE Do not rely on this."]
    pub const LEAPS_1210_TO_1500: [Self; 71] =
        unsafe { ::core::mem::transmute(crate::Year::LEAPS_1210_TO_1500) };
    #[doc = " Years that are not leap while 33-year rule marks them as leap.\n\n \"All these years are not leap, while they are considered leap by the 33-year\n rule. The year following each of them is leap, but it's considered non-leap\n by the 33-year rule. This table has been tested to match the modified\n astronomical algorithm based on the 52.5 degrees east meridian from 1178 AP\n (an arbitrary date before the Persian calendar was adopted in 1304 AP) to\n 3000 AP (an arbitrary date far into the future).\"\n\n Taken from\n <https://github.com/unicode-org/icu4x/blob/3e3da0a0a34bfe3056d0f89183270ea683f4a23c/utils/calendrical_calculations/src/persian.rs#L23>"]
    pub const NON_LEAP_CORRECTION: [Self; 78] =
        unsafe { ::core::mem::transmute(crate::Year::NON_LEAP_CORRECTION) };
}
#[cfg_attr(feature = "wasm", wasm_bindgen)]
impl Year {
    #[cfg_attr(feature = "wasm", wasm_bindgen(constructor))]
    #[doc = " Create a valid year and if 0, replace it with -1 ([`Self::ZERO_REPLACEMENT`] in effect)."]
    pub fn new(value: IYear) -> Year {
        unsafe { ::core::mem::transmute(crate::Year::new(value.into())) }
    }
}
#[cfg(feature = "py")]
#[pymethods]
impl Year {
    #[cfg(feature = "py")]
    #[new]
    #[doc = " Create a valid year and if 0, replace it with -1 ([`Self::ZERO_REPLACEMENT`] in effect)."]
    pub fn __py_only_new(value: IYear) -> Year {
        unsafe { ::core::mem::transmute(crate::Year::new(value.into())) }
    }
}
